# 스마트홈 IoT V3 구현 가이드 - 엔터프라이즈 플랫폼

## 1. V3 개요 및 전환 전략

### 1.1 V3 핵심 목표
- **B2B SaaS 전환**: 멀티테넌시 기반 엔터프라이즈 솔루션
- **글로벌 확장**: 다중 지역 배포 및 다국어 지원
- **마이크로서비스**: 독립적으로 확장 가능한 서비스 아키텍처
- **엔터프라이즈 통합**: 주요 비즈니스 시스템과의 연동
- **고급 분석**: AI 기반 비즈니스 인텔리전스

### 1.2 단계적 전환 계획
```yaml
Phase 1 (Month 1-2): 기반 구축
  - 마이크로서비스 아키텍처 설계
  - 멀티테넌시 데이터베이스 설계
  - API Gateway 구축
  - CI/CD 파이프라인 고도화

Phase 2 (Month 3-4): 핵심 서비스 분리
  - Device Management Service
  - Telemetry Service
  - Authentication Service
  - Tenant Management Service

Phase 3 (Month 5-6): 엔터프라이즈 기능
  - Analytics Platform
  - Integration Hub
  - White-label Support
  - Global Deployment
```

## 2. 멀티테넌시 구현

### 2.1 테넌트 격리 전략

```javascript
// backend/services/tenant-service/src/models/tenant.js
const { Model, DataTypes } = require('sequelize');

class Tenant extends Model {
  static init(sequelize) {
    return super.init({
      id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      identifier: {
        type: DataTypes.STRING,
        unique: true,
        allowNull: false
      },
      name: {
        type: DataTypes.STRING,
        allowNull: false
      },
      plan: {
        type: DataTypes.ENUM('starter', 'professional', 'enterprise'),
        defaultValue: 'starter'
      },
      settings: {
        type: DataTypes.JSONB,
        defaultValue: {
          branding: {},
          features: {},
          limits: {},
          integrations: {}
        }
      },
      status: {
        type: DataTypes.ENUM('active', 'suspended', 'cancelled'),
        defaultValue: 'active'
      },
      metadata: {
        type: DataTypes.JSONB,
        defaultValue: {}
      }
    }, {
      sequelize,
      modelName: 'Tenant',
      tableName: 'tenants',
      hooks: {
        afterCreate: async (tenant) => {
          // 테넌트별 스키마 생성
          await sequelize.query(`CREATE SCHEMA IF NOT EXISTS tenant_${tenant.identifier}`);
          
          // 테넌트별 테이블 생성
          await this.createTenantTables(tenant.identifier);
          
          // 기본 데이터 초기화
          await this.initializeTenantData(tenant);
        }
      }
    });
  }

  static async createTenantTables(tenantId) {
    const tables = [
      'devices', 'device_states', 'telemetry', 
      'automations', 'scenes', 'users', 'api_keys'
    ];
    
    for (const table of tables) {
      await sequelize.query(`
        CREATE TABLE tenant_${tenantId}.${table} 
        (LIKE public.${table} INCLUDING ALL)
      `);
    }
  }
}

// 테넌트 컨텍스트 미들웨어
class TenantContext {
  constructor() {
    this.tenantCache = new Map();
  }

  async middleware(req, res, next) {
    try {
      // 테넌트 식별 (subdomain, header, JWT claim)
      const tenantId = this.extractTenantId(req);
      
      if (!tenantId) {
        return res.status(400).json({ error: 'Tenant identification required' });
      }

      // 캐시에서 테넌트 정보 조회
      let tenant = this.tenantCache.get(tenantId);
      
      if (!tenant) {
        tenant = await Tenant.findOne({ 
          where: { identifier: tenantId, status: 'active' } 
        });
        
        if (!tenant) {
          return res.status(404).json({ error: 'Tenant not found' });
        }
        
        this.tenantCache.set(tenantId, tenant);
      }

      // 요청 컨텍스트에 테넌트 정보 추가
      req.tenant = tenant;
      req.tenantId = tenant.identifier;
      
      // 데이터베이스 연결을 테넌트 스키마로 설정
      req.db = await this.getTenantConnection(tenant.identifier);
      
      // Row-Level Security 설정
      await req.db.query(`SET app.current_tenant = '${tenant.id}'`);
      
      next();
    } catch (error) {
      console.error('Tenant context error:', error);
      res.status(500).json({ error: 'Tenant context initialization failed' });
    }
  }

  extractTenantId(req) {
    // 1. Subdomain에서 추출
    const subdomain = req.hostname.split('.')[0];
    if (subdomain && subdomain !== 'www') {
      return subdomain;
    }
    
    // 2. Custom header에서 추출
    if (req.headers['x-tenant-id']) {
      return req.headers['x-tenant-id'];
    }
    
    // 3. JWT claim에서 추출
    if (req.user && req.user.tenantId) {
      return req.user.tenantId;
    }
    
    return null;
  }

  async getTenantConnection(tenantId) {
    // 테넌트별 데이터베이스 연결 풀 관리
    const config = {
      ...baseDbConfig,
      schema: `tenant_${tenantId}`,
      searchPath: [`tenant_${tenantId}`, 'public']
    };
    
    return new Sequelize(config);
  }
}
```

### 2.2 화이트라벨 지원

```javascript
// backend/services/tenant-service/src/services/brandingService.js
class BrandingService {
  constructor() {
    this.brandingCache = new LRUCache({ max: 100, ttl: 1000 * 60 * 60 });
  }

  async getBranding(tenantId) {
    const cached = this.brandingCache.get(tenantId);
    if (cached) return cached;

    const tenant = await Tenant.findOne({ 
      where: { identifier: tenantId } 
    });

    const branding = {
      // 기본 브랜딩
      logo: tenant.settings.branding.logo || '/default-logo.svg',
      favicon: tenant.settings.branding.favicon || '/favicon.ico',
      appName: tenant.settings.branding.appName || 'Smart Home Platform',
      
      // 색상 테마
      theme: {
        primary: tenant.settings.branding.colors?.primary || '#2563eb',
        secondary: tenant.settings.branding.colors?.secondary || '#7c3aed',
        accent: tenant.settings.branding.colors?.accent || '#f59e0b',
        ...tenant.settings.branding.colors
      },
      
      // 커스텀 CSS
      customCss: tenant.settings.branding.customCss || '',
      
      // 이메일 템플릿
      emailTemplates: await this.getEmailTemplates(tenantId),
      
      // 음성 설정
      voiceSettings: {
        wakeWord: tenant.settings.branding.voiceWakeWord || 'Hey Home',
        voicePersona: tenant.settings.branding.voicePersona || 'assistant'
      },
      
      // 도메인 설정
      customDomain: tenant.settings.branding.customDomain,
      
      // 기능 플래그
      features: tenant.settings.features || {}
    };

    this.brandingCache.set(tenantId, branding);
    return branding;
  }

  async getEmailTemplates(tenantId) {
    const defaultTemplates = await this.loadDefaultTemplates();
    const customTemplates = await EmailTemplate.findAll({ 
      where: { tenantId } 
    });

    // 커스텀 템플릿으로 기본 템플릿 오버라이드
    return {
      ...defaultTemplates,
      ...customTemplates.reduce((acc, t) => ({ 
        ...acc, 
        [t.name]: t.content 
      }), {})
    };
  }

  async updateBranding(tenantId, updates) {
    const tenant = await Tenant.findOne({ 
      where: { identifier: tenantId } 
    });

    tenant.settings.branding = {
      ...tenant.settings.branding,
      ...updates
    };

    await tenant.save();
    
    // 캐시 무효화
    this.brandingCache.delete(tenantId);
    
    // CDN 캐시 퍼지
    await this.purgeCDNCache(tenantId);
    
    return tenant.settings.branding;
  }
}

// Frontend 화이트라벨 적용
// frontend/src/composables/useBranding.js
import { ref, computed, watch } from 'vue';
import { useRoute } from 'vue-router';

export function useBranding() {
  const branding = ref({});
  const route = useRoute();

  const loadBranding = async () => {
    const tenantId = window.location.hostname.split('.')[0];
    const response = await fetch(`/api/branding/${tenantId}`);
    branding.value = await response.json();
    
    // 동적 스타일 적용
    applyBrandingStyles(branding.value);
  };

  const applyBrandingStyles = (brandingData) => {
    const root = document.documentElement;
    
    // CSS 변수 설정
    Object.entries(brandingData.theme).forEach(([key, value]) => {
      root.style.setProperty(`--color-${key}`, value);
    });
    
    // 커스텀 CSS 삽입
    if (brandingData.customCss) {
      const style = document.createElement('style');
      style.textContent = brandingData.customCss;
      document.head.appendChild(style);
    }
    
    // 파비콘 변경
    const favicon = document.querySelector('link[rel="icon"]');
    if (favicon) {
      favicon.href = brandingData.favicon;
    }
    
    // 타이틀 변경
    document.title = brandingData.appName;
  };

  // 라우트 변경 시 브랜딩 재로드
  watch(() => route.path, loadBranding);

  return {
    branding: computed(() => branding.value),
    logo: computed(() => branding.value.logo),
    theme: computed(() => branding.value.theme),
    appName: computed(() => branding.value.appName),
    features: computed(() => branding.value.features || {})
  };
}
```

## 3. 마이크로서비스 아키텍처

### 3.1 Device Management Service

```javascript
// services/device-service/src/index.js
const express = require('express');
const { Kafka } = require('kafkajs');
const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');
const { createProxyMiddleware } = require('http-proxy-middleware');

class DeviceManagementService {
  constructor() {
    this.app = express();
    this.kafka = new Kafka({
      clientId: 'device-service',
      brokers: process.env.KAFKA_BROKERS.split(',')
    });
    
    this.producer = this.kafka.producer();
    this.consumer = this.kafka.consumer({ groupId: 'device-service-group' });
    
    this.setupGRPC();
    this.setupHTTP();
    this.setupEventHandlers();
  }

  setupGRPC() {
    // gRPC 서버 설정 (내부 서비스 통신)
    const packageDefinition = protoLoader.loadSync('./proto/device.proto', {
      keepCase: true,
      longs: String,
      enums: String,
      defaults: true,
      oneofs: true
    });

    const deviceProto = grpc.loadPackageDefinition(packageDefinition).device;
    
    this.grpcServer = new grpc.Server();
    
    this.grpcServer.addService(deviceProto.DeviceService.service, {
      getDevice: this.getDevice.bind(this),
      listDevices: this.listDevices.bind(this),
      updateDevice: this.updateDevice.bind(this),
      streamDeviceStatus: this.streamDeviceStatus.bind(this)
    });

    this.grpcServer.bindAsync(
      '0.0.0.0:50051',
      grpc.ServerCredentials.createInsecure(),
      () => {
        console.log('gRPC server running on port 50051');
        this.grpcServer.start();
      }
    );
  }

  setupHTTP() {
    // REST API (외부 접근용)
    this.app.use(express.json());
    this.app.use(this.tenantMiddleware);
    
    // 헬스체크
    this.app.get('/health', (req, res) => {
      res.json({ 
        status: 'healthy', 
        service: 'device-management',
        version: process.env.SERVICE_VERSION 
      });
    });

    // Device CRUD
    this.app.post('/devices', this.createDevice.bind(this));
    this.app.get('/devices', this.listDevicesHTTP.bind(this));
    this.app.get('/devices/:id', this.getDeviceHTTP.bind(this));
    this.app.put('/devices/:id', this.updateDeviceHTTP.bind(this));
    this.app.delete('/devices/:id', this.deleteDevice.bind(this));
    
    // Bulk operations
    this.app.post('/devices/bulk', this.bulkCreateDevices.bind(this));
    this.app.post('/devices/bulk/command', this.bulkCommand.bind(this));
    
    // 메트릭 엔드포인트
    this.app.get('/metrics', this.getMetrics.bind(this));
  }

  async createDevice(req, res) {
    try {
      const { tenantId } = req;
      const deviceData = req.body;
      
      // 입력 검증
      const validation = await this.validateDevice(deviceData);
      if (!validation.valid) {
        return res.status(400).json({ error: validation.errors });
      }
      
      // 디바이스 생성
      const device = await Device.create({
        ...deviceData,
        tenantId,
        id: generateDeviceId(tenantId)
      });
      
      // 이벤트 발행
      await this.producer.send({
        topic: 'device-events',
        messages: [{
          key: device.id,
          value: JSON.stringify({
            event: 'device.created',
            tenantId,
            deviceId: device.id,
            data: device,
            timestamp: new Date()
          })
        }]
      });
      
      // 캐시 업데이트
      await this.updateCache(tenantId, device.id, device);
      
      res.status(201).json({ device });
      
    } catch (error) {
      console.error('Create device error:', error);
      res.status(500).json({ error: 'Failed to create device' });
    }
  }

  async bulkCreateDevices(req, res) {
    const { tenantId } = req;
    const { devices, options = {} } = req.body;
    
    // 배치 처리 옵션
    const batchSize = options.batchSize || 100;
    const parallel = options.parallel || 5;
    
    const results = {
      success: [],
      failed: [],
      total: devices.length
    };
    
    // 청크로 나누기
    const chunks = [];
    for (let i = 0; i < devices.length; i += batchSize) {
      chunks.push(devices.slice(i, i + batchSize));
    }
    
    // 병렬 처리
    const promises = [];
    for (let i = 0; i < chunks.length; i += parallel) {
      const batch = chunks.slice(i, i + parallel);
      promises.push(
        Promise.all(
          batch.map(chunk => this.processBatch(tenantId, chunk, results))
        )
      );
    }
    
    await Promise.all(promises);
    
    res.json({
      summary: {
        total: results.total,
        success: results.success.length,
        failed: results.failed.length
      },
      results: options.detailed ? results : undefined
    });
  }

  // gRPC 메서드
  async getDevice(call, callback) {
    const { tenantId, deviceId } = call.request;
    
    try {
      const device = await this.deviceRepository.findOne({
        tenantId,
        id: deviceId
      });
      
      if (!device) {
        return callback({
          code: grpc.status.NOT_FOUND,
          message: 'Device not found'
        });
      }
      
      callback(null, device);
    } catch (error) {
      callback({
        code: grpc.status.INTERNAL,
        message: error.message
      });
    }
  }

  streamDeviceStatus(call) {
    const { tenantId, deviceIds } = call.request;
    
    // 실시간 상태 스트리밍
    const subscription = this.statusStream
      .filter(status => 
        status.tenantId === tenantId && 
        deviceIds.includes(status.deviceId)
      )
      .subscribe(status => {
        call.write(status);
      });
    
    call.on('cancelled', () => {
      subscription.unsubscribe();
    });
  }
}

// Device Service Proto 정의
// proto/device.proto
syntax = "proto3";

package device;

service DeviceService {
  rpc GetDevice (GetDeviceRequest) returns (Device);
  rpc ListDevices (ListDevicesRequest) returns (DeviceList);
  rpc UpdateDevice (UpdateDeviceRequest) returns (Device);
  rpc StreamDeviceStatus (StreamRequest) returns (stream DeviceStatus);
}

message Device {
  string id = 1;
  string tenant_id = 2;
  string name = 3;
  string type = 4;
  map<string, string> metadata = 5;
  DeviceStatus status = 6;
  int64 created_at = 7;
  int64 updated_at = 8;
}

message DeviceStatus {
  string device_id = 1;
  bool online = 2;
  map<string, string> state = 3;
  int64 last_seen = 4;
}
```

### 3.2 Analytics Service

```javascript
// services/analytics-service/src/index.js
const { ClickHouse } = require('clickhouse');
const { Kafka } = require('kafkajs');
const tf = require('@tensorflow/tfjs-node');

class AnalyticsService {
  constructor() {
    this.clickhouse = new ClickHouse({
      url: process.env.CLICKHOUSE_URL,
      port: 8123,
      debug: false,
      basicAuth: {
        username: process.env.CLICKHOUSE_USER,
        password: process.env.CLICKHOUSE_PASSWORD
      }
    });
    
    this.initializeDatabase();
    this.setupStreamProcessing();
    this.loadMLModels();
  }

  async initializeDatabase() {
    // ClickHouse 테이블 생성
    await this.clickhouse.query(`
      CREATE TABLE IF NOT EXISTS device_metrics (
        tenant_id String,
        device_id String,
        timestamp DateTime,
        metric_name String,
        metric_value Float64,
        tags Nested(
          key String,
          value String
        ),
        INDEX idx_tenant_device (tenant_id, device_id) TYPE minmax GRANULARITY 8192,
        INDEX idx_timestamp (timestamp) TYPE minmax GRANULARITY 8192
      )
      ENGINE = MergeTree()
      PARTITION BY toYYYYMM(timestamp)
      ORDER BY (tenant_id, device_id, timestamp)
      TTL timestamp + INTERVAL 90 DAY
    `).toPromise();

    // 집계 테이블
    await this.clickhouse.query(`
      CREATE MATERIALIZED VIEW IF NOT EXISTS device_metrics_hourly
      ENGINE = SummingMergeTree()
      PARTITION BY toYYYYMM(date)
      ORDER BY (tenant_id, device_id, date, hour, metric_name)
      AS SELECT
        tenant_id,
        device_id,
        toDate(timestamp) as date,
        toHour(timestamp) as hour,
        metric_name,
        avg(metric_value) as avg_value,
        min(metric_value) as min_value,
        max(metric_value) as max_value,
        count() as sample_count
      FROM device_metrics
      GROUP BY tenant_id, device_id, date, hour, metric_name
    `).toPromise();
  }

  async setupStreamProcessing() {
    const kafka = new Kafka({
      clientId: 'analytics-service',
      brokers: process.env.KAFKA_BROKERS.split(',')
    });

    const consumer = kafka.consumer({ 
      groupId: 'analytics-consumer-group' 
    });

    await consumer.connect();
    await consumer.subscribe({ 
      topics: ['device-telemetry', 'device-events'],
      fromBeginning: false 
    });

    await consumer.run({
      eachMessage: async ({ topic, partition, message }) => {
        const data = JSON.parse(message.value.toString());
        
        switch (topic) {
          case 'device-telemetry':
            await this.processTelemetry(data);
            break;
          case 'device-events':
            await this.processEvent(data);
            break;
        }
      }
    });
  }

  async processTelemetry(data) {
    const { tenantId, deviceId, metrics, timestamp } = data;
    
    // ClickHouse에 저장
    const insertData = metrics.map(metric => ({
      tenant_id: tenantId,
      device_id: deviceId,
      timestamp: new Date(timestamp),
      metric_name: metric.name,
      metric_value: metric.value,
      tags: metric.tags || []
    }));

    await this.clickhouse.insert(
      'INSERT INTO device_metrics',
      insertData
    ).toPromise();

    // 실시간 이상 감지
    await this.detectAnomalies(tenantId, deviceId, metrics);
    
    // 실시간 집계 업데이트
    await this.updateRealTimeAggregates(tenantId, deviceId, metrics);
  }

  async detectAnomalies(tenantId, deviceId, metrics) {
    for (const metric of metrics) {
      const model = this.anomalyModels.get(`${metric.name}`);
      if (!model) continue;

      // 최근 데이터 조회
      const recentData = await this.getRecentMetrics(
        tenantId, 
        deviceId, 
        metric.name, 
        100
      );

      // 특징 추출
      const features = this.extractFeatures(recentData);
      const prediction = model.predict(features);
      
      const anomalyScore = await prediction.data();
      
      if (anomalyScore[0] > 0.8) {
        // 이상 감지 알림
        await this.sendAnomalyAlert({
          tenantId,
          deviceId,
          metric: metric.name,
          value: metric.value,
          anomalyScore: anomalyScore[0],
          timestamp: new Date()
        });
      }
    }
  }

  // REST API 엔드포인트
  async getDeviceAnalytics(req, res) {
    const { tenantId } = req;
    const { deviceId } = req.params;
    const { start, end, metrics, aggregation = 'hour' } = req.query;

    try {
      const query = `
        SELECT
          toStartOfInterval(timestamp, INTERVAL 1 ${aggregation}) as time,
          metric_name,
          avg(metric_value) as avg_value,
          min(metric_value) as min_value,
          max(metric_value) as max_value,
          count() as sample_count
        FROM device_metrics
        WHERE tenant_id = {tenantId:String}
          AND device_id = {deviceId:String}
          AND timestamp >= {start:DateTime}
          AND timestamp <= {end:DateTime}
          ${metrics ? `AND metric_name IN {metrics:Array(String)}` : ''}
        GROUP BY time, metric_name
        ORDER BY time ASC
      `;

      const result = await this.clickhouse.query(query, {
        tenantId,
        deviceId,
        start: new Date(start),
        end: new Date(end),
        metrics: metrics ? metrics.split(',') : undefined
      }).toPromise();

      res.json({
        deviceId,
        period: { start, end },
        aggregation,
        data: result.data
      });

    } catch (error) {
      console.error('Analytics query error:', error);
      res.status(500).json({ error: 'Failed to fetch analytics' });
    }
  }

  async getTenantInsights(req, res) {
    const { tenantId } = req;
    const { period = '30d' } = req.query;

    try {
      // 다차원 분석
      const insights = await Promise.all([
        this.getDeviceUsagePatterns(tenantId, period),
        this.getEnergyConsumption(tenantId, period),
        this.getAutomationEfficiency(tenantId, period),
        this.getPredictiveMaintenance(tenantId),
        this.getCostSavings(tenantId, period)
      ]);

      const [usage, energy, automation, maintenance, savings] = insights;

      res.json({
        tenantId,
        period,
        insights: {
          deviceUsage: usage,
          energyConsumption: energy,
          automationEfficiency: automation,
          predictiveMaintenance: maintenance,
          costSavings: savings
        },
        recommendations: await this.generateRecommendations(insights)
      });

    } catch (error) {
      console.error('Insights generation error:', error);
      res.status(500).json({ error: 'Failed to generate insights' });
    }
  }

  async getDeviceUsagePatterns(tenantId, period) {
    const query = `
      WITH device_sessions AS (
        SELECT 
          device_id,
          toDate(timestamp) as date,
          toHour(timestamp) as hour,
          sum(metric_value) as usage_minutes
        FROM device_metrics
        WHERE tenant_id = {tenantId:String}
          AND metric_name = 'usage_time'
          AND timestamp >= now() - INTERVAL {period:String}
        GROUP BY device_id, date, hour
      )
      SELECT 
        device_id,
        avg(usage_minutes) as avg_daily_usage,
        max(usage_minutes) as peak_usage,
        groupArray(tuple(hour, avg(usage_minutes))) as hourly_pattern
      FROM device_sessions
      GROUP BY device_id
    `;

    const result = await this.clickhouse.query(query, {
      tenantId,
      period
    }).toPromise();

    return {
      patterns: result.data,
      insights: this.analyzeUsagePatterns(result.data)
    };
  }

  async generateRecommendations(insights) {
    const recommendations = [];

    // 사용량 기반 추천
    if (insights[0].insights.underutilized.length > 0) {
      recommendations.push({
        type: 'optimization',
        priority: 'medium',
        title: 'Underutilized Devices',
        description: `${insights[0].insights.underutilized.length} devices show low usage. Consider automation or relocation.`,
        devices: insights[0].insights.underutilized
      });
    }

    // 에너지 절약 추천
    if (insights[1].savingsPotential > 100) {
      recommendations.push({
        type: 'cost_saving',
        priority: 'high',
        title: 'Energy Saving Opportunity',
        description: `Potential monthly savings of $${insights[1].savingsPotential.toFixed(2)} through optimized scheduling.`,
        actions: insights[1].recommendations
      });
    }

    // 예측 유지보수 추천
    insights[3].alerts.forEach(alert => {
      recommendations.push({
        type: 'maintenance',
        priority: alert.priority,
        title: `Maintenance Required: ${alert.deviceName}`,
        description: alert.description,
        estimatedDate: alert.estimatedDate
      });
    });

    return recommendations;
  }
}

// 실시간 대시보드 WebSocket
class RealtimeDashboard {
  constructor(analyticsService) {
    this.analytics = analyticsService;
    this.connections = new Map();
  }

  handleConnection(ws, req) {
    const tenantId = this.extractTenantId(req);
    const connectionId = generateId();
    
    this.connections.set(connectionId, {
      ws,
      tenantId,
      subscriptions: new Set()
    });

    ws.on('message', (message) => {
      const data = JSON.parse(message);
      this.handleMessage(connectionId, data);
    });

    ws.on('close', () => {
      this.connections.delete(connectionId);
    });
  }

  async handleMessage(connectionId, data) {
    const connection = this.connections.get(connectionId);
    
    switch (data.type) {
      case 'subscribe':
        await this.subscribe(connection, data.metrics);
        break;
      case 'unsubscribe':
        await this.unsubscribe(connection, data.metrics);
        break;
      case 'query':
        await this.executeQuery(connection, data.query);
        break;
    }
  }

  async subscribe(connection, metrics) {
    metrics.forEach(metric => {
      connection.subscriptions.add(metric);
    });

    // 실시간 데이터 스트림 시작
    this.startStreaming(connection);
  }

  async startStreaming(connection) {
    const interval = setInterval(async () => {
      if (connection.ws.readyState !== 1) {
        clearInterval(interval);
        return;
      }

      const data = await this.analytics.getRealtimeMetrics(
        connection.tenantId,
        Array.from(connection.subscriptions)
      );

      connection.ws.send(JSON.stringify({
        type: 'metrics',
        timestamp: new Date(),
        data
      }));
    }, 1000); // 1초마다 업데이트
  }
}
```

## 4. 엔터프라이즈 통합

### 4.1 Integration Hub

```javascript
// services/integration-service/src/adapters/salesforceAdapter.js
const jsforce = require('jsforce');
const { EventEmitter } = require('events');

class SalesforceAdapter extends EventEmitter {
  constructor(config) {
    super();
    this.config = config;
    this.connections = new Map();
  }

  async connect(tenantId, credentials) {
    const conn = new jsforce.Connection({
      oauth2: {
        clientId: this.config.clientId,
        clientSecret: this.config.clientSecret,
        redirectUri: this.config.redirectUri
      },
      instanceUrl: credentials.instanceUrl,
      accessToken: credentials.accessToken,
      refreshToken: credentials.refreshToken
    });

    // 토큰 갱신 핸들러
    conn.on('refresh', (accessToken) => {
      this.emit('token-refresh', { tenantId, accessToken });
    });

    this.connections.set(tenantId, conn);
    
    // 커스텀 객체 생성 확인
    await this.ensureCustomObjects(conn);
    
    return conn;
  }

  async ensureCustomObjects(conn) {
    // IoT 디바이스 커스텀 객체
    const deviceObject = {
      fullName: 'IoT_Device__c',
      label: 'IoT Device',
      pluralLabel: 'IoT Devices',
      nameField: {
        type: 'Text',
        label: 'Device Name'
      },
      deploymentStatus: 'Deployed',
      sharingModel: 'Private'
    };

    try {
      await conn.metadata.create('CustomObject', deviceObject);
    } catch (error) {
      if (!error.message.includes('already exists')) {
        throw error;
      }
    }

    // 커스텀 필드 생성
    const customFields = [
      {
        fullName: 'IoT_Device__c.Device_ID__c',
        type: 'Text',
        label: 'Device ID',
        length: 255,
        unique: true
      },
      {
        fullName: 'IoT_Device__c.Status__c',
        type: 'Picklist',
        label: 'Status',
        valueSet: {
          valueSetDefinition: {
            value: [
              { fullName: 'Online', label: 'Online' },
              { fullName: 'Offline', label: 'Offline' },
              { fullName: 'Maintenance', label: 'Maintenance' }
            ]
          }
        }
      },
      {
        fullName: 'IoT_Device__c.Last_Seen__c',
        type: 'DateTime',
        label: 'Last Seen'
      },
      {
        fullName: 'IoT_Device__c.Telemetry_Data__c',
        type: 'LongTextArea',
        label: 'Telemetry Data',
        length: 32768,
        visibleLines: 10
      }
    ];

    await conn.metadata.create('CustomField', customFields);
  }

  async syncDevice(tenantId, device) {
    const conn = this.connections.get(tenantId);
    if (!conn) throw new Error('No Salesforce connection for tenant');

    try {
      // 기존 레코드 확인
      const existing = await conn.sobject('IoT_Device__c')
        .find({ Device_ID__c: device.id })
        .limit(1);

      const record = {
        Name: device.name,
        Device_ID__c: device.id,
        Status__c: device.isOnline ? 'Online' : 'Offline',
        Last_Seen__c: device.lastSeen,
        Telemetry_Data__c: JSON.stringify(device.currentState)
      };

      if (existing.length > 0) {
        // 업데이트
        await conn.sobject('IoT_Device__c')
          .update({
            Id: existing[0].Id,
            ...record
          });
      } else {
        // 생성
        await conn.sobject('IoT_Device__c').create(record);
      }

      // 관련 Case 생성 (이상 감지 시)
      if (device.anomalyDetected) {
        await this.createCase(conn, device);
      }

    } catch (error) {
      console.error('Salesforce sync error:', error);
      throw error;
    }
  }

  async createCase(conn, device) {
    const caseRecord = {
      Subject: `IoT Alert: ${device.name}`,
      Description: `Anomaly detected on device ${device.name}. ${device.anomalyDetails}`,
      Priority: device.anomalySeverity || 'Medium',
      Status: 'New',
      Origin: 'IoT Platform',
      Type: 'IoT Alert',
      IoT_Device__c: device.salesforceId
    };

    const result = await conn.sobject('Case').create(caseRecord);
    
    // 알림 전송
    await this.sendChatterNotification(conn, result.id, device);
    
    return result;
  }

  async sendChatterNotification(conn, caseId, device) {
    const feedItem = {
      ParentId: caseId,
      Body: {
        messageSegments: [
          {
            type: 'Text',
            text: `🚨 IoT Alert: ${device.name}\n\n`
          },
          {
            type: 'Text',
            text: `Status: ${device.anomalySeverity}\n`
          },
          {
            type: 'Text',
            text: `Details: ${device.anomalyDetails}\n\n`
          },
          {
            type: 'Text',
            text: 'Please review and take appropriate action.'
          }
        ]
      }
    };

    await conn.chatter.resource('/feed-elements').create(feedItem);
  }

  // 양방향 동기화를 위한 Streaming API 구독
  async subscribeToChanges(tenantId) {
    const conn = this.connections.get(tenantId);
    if (!conn) return;

    // Push Topic 생성
    await conn.sobject('PushTopic').create({
      Name: 'IoTDeviceChanges',
      Query: 'SELECT Id, Name, Device_ID__c, Status__c FROM IoT_Device__c',
      ApiVersion: '52.0',
      NotifyForOperationCreate: true,
      NotifyForOperationUpdate: true,
      NotifyForOperationDelete: true,
      NotifyForFields: 'All'
    });

    // 구독
    conn.streaming.topic('IoTDeviceChanges').subscribe((message) => {
      this.handleSalesforceChange(tenantId, message);
    });
  }

  async handleSalesforceChange(tenantId, message) {
    console.log('Salesforce change:', message);
    
    // IoT 플랫폼에 변경사항 반영
    if (message.event.type === 'updated') {
      const device = await this.getDeviceFromSalesforce(
        tenantId, 
        message.sobject.Device_ID__c
      );
      
      this.emit('device-updated', { tenantId, device });
    }
  }
}

// SAP 통합 어댑터
class SAPAdapter extends EventEmitter {
  constructor(config) {
    super();
    this.config = config;
  }

  async connect(tenantId, credentials) {
    // SAP Cloud SDK 사용
    const destination = {
      name: `tenant-${tenantId}`,
      url: credentials.url,
      username: credentials.username,
      password: credentials.password,
      authentication: 'BasicAuthentication'
    };

    await setDestination(destination);
    
    return destination;
  }

  async syncEquipment(tenantId, device) {
    const equipment = {
      EquipmentNumber: device.id,
      EquipmentName: device.name,
      EquipmentCategory: 'IoT',
      Status: device.isOnline ? 'AVLB' : 'NAVL',
      TechnicalObjectType: 'IOTDEV',
      MaintenanceStatus: device.requiresMaintenance ? 'REQ' : 'OK',
      Location: device.location,
      CustomFields: {
        IoTPlatformId: device.id,
        LastTelemetryUpdate: device.lastSeen,
        SensorData: JSON.stringify(device.currentState)
      }
    };

    try {
      // Equipment 마스터 데이터 업데이트
      await this.updateEquipmentMaster(tenantId, equipment);
      
      // Measurement Document 생성
      if (device.telemetry) {
        await this.createMeasurementDocument(tenantId, device);
      }
      
      // Maintenance Notification 생성 (필요시)
      if (device.requiresMaintenance) {
        await this.createMaintenanceNotification(tenantId, device);
      }
      
    } catch (error) {
      console.error('SAP sync error:', error);
      throw error;
    }
  }

  async createMaintenanceNotification(tenantId, device) {
    const notification = {
      NotificationType: 'M2',
      Equipment: device.id,
      FunctionalLocation: device.location,
      Priority: this.mapPriority(device.maintenancePriority),
      Description: `IoT Predictive Maintenance: ${device.name}`,
      LongText: device.maintenanceDetails,
      RequiredStart: new Date(device.maintenanceDate),
      ReportedBy: 'IoT_PLATFORM'
    };

    const client = await this.getClient(tenantId);
    const result = await client.post('/MaintenanceNotification', notification);
    
    return result.data;
  }
}
```

### 4.2 API 플랫폼

```javascript
// services/api-gateway/src/index.js
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const { OpenAPIValidator } = require('express-openapi-validator');
const swaggerUi = require('swagger-ui-express');

class APIGateway {
  constructor() {
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
    this.setupServiceProxies();
  }

  setupMiddleware() {
    // 보안 헤더
    this.app.use(helmet());
    
    // CORS
    this.app.use(cors({
      origin: (origin, callback) => {
        // 테넌트별 도메인 허용
        if (this.isAllowedOrigin(origin)) {
          callback(null, true);
        } else {
          callback(new Error('Not allowed by CORS'));
        }
      }
    }));

    // Rate Limiting
    this.app.use('/api/', this.createRateLimiter());
    
    // API Key 또는 JWT 인증
    this.app.use('/api/', this.authenticate);
    
    // OpenAPI 검증
    this.app.use(
      OpenAPIValidator.middleware({
        apiSpec: './openapi.yaml',
        validateRequests: true,
        validateResponses: true
      })
    );
  }

  createRateLimiter() {
    return rateLimit({
      windowMs: 60 * 1000, // 1분
      max: (req) => {
        // 플랜별 rate limit
        const limits = {
          starter: 100,
          professional: 1000,
          enterprise: 10000
        };
        return limits[req.tenant?.plan] || 100;
      },
      handler: (req, res) => {
        res.status(429).json({
          error: 'Too many requests',
          retryAfter: req.rateLimit.resetTime
        });
      },
      keyGenerator: (req) => {
        return req.tenant?.id || req.ip;
      }
    });
  }

  async authenticate(req, res, next) {
    try {
      let token;
      
      // Bearer Token
      if (req.headers.authorization?.startsWith('Bearer ')) {
        token = req.headers.authorization.substring(7);
      }
      // API Key
      else if (req.headers['x-api-key']) {
        token = await this.validateAPIKey(req.headers['x-api-key']);
      }
      
      if (!token) {
        return res.status(401).json({ error: 'Authentication required' });
      }
      
      // JWT 검증
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // 테넌트 정보 로드
      req.tenant = await this.getTenant(decoded.tenantId);
      req.user = decoded;
      
      // 권한 검증
      if (!this.checkPermissions(req)) {
        return res.status(403).json({ error: 'Insufficient permissions' });
      }
      
      next();
    } catch (error) {
      res.status(401).json({ error: 'Invalid authentication' });
    }
  }

  setupServiceProxies() {
    // 서비스별 프록시 설정
    const services = {
      '/api/devices': {
        target: 'http://device-service:3001',
        pathRewrite: { '^/api/devices': '/devices' }
      },
      '/api/telemetry': {
        target: 'http://telemetry-service:3002',
        pathRewrite: { '^/api/telemetry': '/telemetry' }
      },
      '/api/analytics': {
        target: 'http://analytics-service:3003',
        pathRewrite: { '^/api/analytics': '/analytics' }
      },
      '/api/automation': {
        target: 'http://automation-service:3004',
        pathRewrite: { '^/api/automation': '/automation' }
      },
      '/api/voice': {
        target: 'http://voice-service:3005',
        pathRewrite: { '^/api/voice': '/voice' }
      }
    };

    Object.entries(services).forEach(([path, config]) => {
      this.app.use(
        path,
        createProxyMiddleware({
          ...config,
          changeOrigin: true,
          onProxyReq: (proxyReq, req) => {
            // 테넌트 정보 전달
            proxyReq.setHeader('X-Tenant-ID', req.tenant.id);
            proxyReq.setHeader('X-User-ID', req.user.id);
          },
          onError: (err, req, res) => {
            res.status(503).json({
              error: 'Service temporarily unavailable',
              service: path
            });
          }
        })
      );
    });
  }

  setupRoutes() {
    // API 문서
    this.app.use('/api/docs', swaggerUi.serve, swaggerUi.setup(
      require('./openapi.json'),
      {
        customCss: '.swagger-ui .topbar { display: none }',
        customSiteTitle: 'IoT Platform API Documentation'
      }
    ));

    // GraphQL 엔드포인트
    this.app.use('/api/graphql', this.graphqlHandler());
    
    // Webhook 등록
    this.app.post('/api/webhooks', this.registerWebhook);
    this.app.delete('/api/webhooks/:id', this.unregisterWebhook);
    
    // API 사용량 조회
    this.app.get('/api/usage', this.getAPIUsage);
  }

  graphqlHandler() {
    const { GraphQLSchema, GraphQLObjectType } = require('graphql');
    const { graphqlHTTP } = require('express-graphql');
    const DataLoader = require('dataloader');

    const schema = new GraphQLSchema({
      query: new GraphQLObjectType({
        name: 'Query',
        fields: {
          device: {
            type: DeviceType,
            args: { id: { type: GraphQLString } },
            resolve: (parent, args, context) => {
              return context.deviceLoader.load(args.id);
            }
          },
          devices: {
            type: new GraphQLList(DeviceType),
            args: {
              limit: { type: GraphQLInt },
              offset: { type: GraphQLInt },
              filter: { type: DeviceFilterInput }
            },
            resolve: async (parent, args, context) => {
              return context.deviceService.list({
                tenantId: context.tenant.id,
                ...args
              });
            }
          },
          analytics: {
            type: AnalyticsType,
            args: {
              deviceId: { type: GraphQLString },
              period: { type: PeriodInput },
              metrics: { type: new GraphQLList(GraphQLString) }
            },
            resolve: async (parent, args, context) => {
              return context.analyticsService.query({
                tenantId: context.tenant.id,
                ...args
              });
            }
          }
        }
      }),
      mutation: new GraphQLObjectType({
        name: 'Mutation',
        fields: {
          createDevice: {
            type: DeviceType,
            args: { input: { type: CreateDeviceInput } },
            resolve: async (parent, args, context) => {
              return context.deviceService.create({
                tenantId: context.tenant.id,
                ...args.input
              });
            }
          },
          controlDevice: {
            type: DeviceControlResultType,
            args: {
              deviceId: { type: GraphQLString },
              command: { type: DeviceCommandInput }
            },
            resolve: async (parent, args, context) => {
              return context.deviceService.control({
                tenantId: context.tenant.id,
                ...args
              });
            }
          }
        }
      })
    });

    return graphqlHTTP((req) => ({
      schema,
      context: {
        tenant: req.tenant,
        user: req.user,
        deviceLoader: new DataLoader(ids => this.batchLoadDevices(req.tenant.id, ids)),
        deviceService: this.deviceService,
        analyticsService: this.analyticsService
      },
      graphiql: process.env.NODE_ENV === 'development'
    }));
  }

  async registerWebhook(req, res) {
    const { url, events, secret } = req.body;
    const { tenant } = req;

    // Webhook 등록
    const webhook = await Webhook.create({
      tenantId: tenant.id,
      url,
      events,
      secret,
      active: true
    });

    // 검증을 위한 challenge 전송
    const challenge = generateChallenge();
    const response = await axios.post(url, {
      type: 'webhook.verify',
      challenge
    }, {
      headers: {
        'X-Webhook-Signature': this.signPayload(challenge, secret)
      }
    });

    if (response.data.challenge !== challenge) {
      await webhook.destroy();
      return res.status(400).json({ error: 'Webhook verification failed' });
    }

    res.json({
      id: webhook.id,
      url: webhook.url,
      events: webhook.events,
      createdAt: webhook.createdAt
    });
  }
}

// OpenAPI 스펙
openapi: 3.0.0
info:
  title: IoT Platform API
  version: 3.0.0
  description: Enterprise IoT Platform API

servers:
  - url: https://api.iot-platform.com/v3
    description: Production
  - url: https://api-staging.iot-platform.com/v3
    description: Staging

security:
  - BearerAuth: []
  - ApiKeyAuth: []

paths:
  /devices:
    get:
      summary: List devices
      operationId: listDevices
      parameters:
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
            maximum: 100
        - name: offset
          in: query
          schema:
            type: integer
            default: 0
        - name: filter
          in: query
          style: deepObject
          explode: true
          schema:
            type: object
            properties:
              type:
                type: string
              status:
                type: string
                enum: [online, offline]
              location:
                type: string
      responses:
        200:
          description: Device list
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/Device'
                  pagination:
                    $ref: '#/components/schemas/Pagination'

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
    ApiKeyAuth:
      type: apiKey
      in: header
      name: X-API-Key
```

## 5. 글로벌 배포 및 확장

### 5.1 Multi-Region 배포

```yaml
# kubernetes/multi-region-deployment.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: iot-platform-prod
---
# Global Traffic Manager
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: global-ingress
  annotations:
    kubernetes.io/ingress.class: "nginx"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/geolocation: "true"
spec:
  tls:
  - hosts:
    - "*.iot-platform.com"
    secretName: wildcard-tls
  rules:
  - host: "api.iot-platform.com"
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-gateway
            port:
              number: 80
---
# Regional API Gateway Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-gateway
  labels:
    app: api-gateway
    region: asia-northeast
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api-gateway
  template:
    metadata:
      labels:
        app: api-gateway
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - api-gateway
            topologyKey: kubernetes.io/hostname
      containers:
      - name: api-gateway
        image: iot-platform/api-gateway:3.0.0
        ports:
        - containerPort: 3000
        env:
        - name: REGION
          value: "asia-northeast"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
# HorizontalPodAutoscaler
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-gateway-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api-gateway
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  - type: Pods
    pods:
      metric:
        name: http_requests_per_second
      target:
        type: AverageValue
        averageValue: "1000"
```

### 5.2 데이터베이스 샤딩

```javascript
// services/database/sharding-strategy.js
class ShardingStrategy {
  constructor() {
    this.shards = new Map();
    this.shardCount = parseInt(process.env.SHARD_COUNT || '4');
    this.initializeShards();
  }

  initializeShards() {
    for (let i = 0; i < this.shardCount; i++) {
      const shard = new Sequelize({
        host: process.env[`SHARD_${i}_HOST`],
        port: process.env[`SHARD_${i}_PORT`],
        database: process.env[`SHARD_${i}_DB`],
        username: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        dialect: 'postgres',
        pool: {
          max: 20,
          min: 5,
          acquire: 30000,
          idle: 10000
        }
      });

      this.shards.set(i, shard);
    }
  }

  getShardKey(tenantId) {
    // Consistent hashing으로 테넌트를 샤드에 할당
    const hash = crypto.createHash('md5').update(tenantId).digest();
    const hashInt = parseInt(hash.toString('hex').substring(0, 8), 16);
    return hashInt % this.shardCount;
  }

  getConnection(tenantId) {
    const shardKey = this.getShardKey(tenantId);
    return this.shards.get(shardKey);
  }

  async rebalanceShards() {
    // 샤드 리밸런싱 로직
    console.log('Starting shard rebalancing...');
    
    // 1. 새 샤드 맵 계산
    const newShardMap = await this.calculateNewShardMap();
    
    // 2. 마이그레이션 계획 생성
    const migrationPlan = await this.createMigrationPlan(newShardMap);
    
    // 3. 단계별 마이그레이션 실행
    for (const migration of migrationPlan) {
      await this.migrateTenant(
        migration.tenantId,
        migration.fromShard,
        migration.toShard
      );
    }
    
    console.log('Shard rebalancing completed');
  }

  async migrateTenant(tenantId, fromShard, toShard) {
    const sourceConn = this.shards.get(fromShard);
    const targetConn = this.shards.get(toShard);
    
    const transaction = await targetConn.transaction();
    
    try {
      // 1. 스키마 복사
      await this.copySchema(tenantId, sourceConn, targetConn);
      
      // 2. 데이터 복사
      await this.copyData(tenantId, sourceConn, targetConn);
      
      // 3. 라우팅 업데이트
      await this.updateRouting(tenantId, toShard);
      
      // 4. 검증
      await this.verifyMigration(tenantId, sourceConn, targetConn);
      
      await transaction.commit();
      
      // 5. 소스 데이터 정리
      await this.cleanupSource(tenantId, sourceConn);
      
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
}
```

## 6. V3 모니터링 및 운영

### 6.1 통합 모니터링 대시보드

```javascript
// monitoring/unified-dashboard.js
const { PrometheusClient } = require('./prometheus');
const { ElasticsearchClient } = require('./elasticsearch');
const { JaegerClient } = require('./jaeger');

class UnifiedMonitoring {
  constructor() {
    this.prometheus = new PrometheusClient();
    this.elasticsearch = new ElasticsearchClient();
    this.jaeger = new JaegerClient();
  }

  async getSystemHealth() {
    const [metrics, logs, traces] = await Promise.all([
      this.getMetrics(),
      this.getRecentLogs(),
      this.getTraces()
    ]);

    return {
      status: this.calculateOverallStatus(metrics),
      services: this.getServiceHealth(metrics, logs),
      performance: {
        p50: metrics.latency_p50,
        p95: metrics.latency_p95,
        p99: metrics.latency_p99
      },
      errors: this.getErrorSummary(logs),
      alerts: await this.getActiveAlerts(),
      sla: this.calculateSLA(metrics)
    };
  }

  async getMetrics() {
    const queries = {
      requestRate: 'sum(rate(http_requests_total[5m]))',
      errorRate: 'sum(rate(http_requests_total{status=~"5.."}[5m]))',
      latency_p50: 'histogram_quantile(0.5, http_request_duration_seconds_bucket)',
      latency_p95: 'histogram_quantile(0.95, http_request_duration_seconds_bucket)',
      latency_p99: 'histogram_quantile(0.99, http_request_duration_seconds_bucket)',
      activeDevices: 'sum(device_active_total)',
      cpuUsage: 'avg(100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100))',
      memoryUsage: 'avg((1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100)'
    };

    const results = {};
    for (const [name, query] of Object.entries(queries)) {
      results[name] = await this.prometheus.query(query);
    }

    return results;
  }

  async getServiceHealth(metrics, logs) {
    const services = [
      'api-gateway',
      'device-service',
      'telemetry-service',
      'analytics-service',
      'automation-service',
      'voice-service'
    ];

    const health = {};
    
    for (const service of services) {
      const serviceMetrics = await this.prometheus.query(`
        up{job="${service}"}
      `);

      const errorLogs = logs.filter(log => 
        log.service === service && 
        log.level === 'error'
      );

      health[service] = {
        status: serviceMetrics.value === 1 ? 'healthy' : 'unhealthy',
        uptime: await this.getUptime(service),
        errorCount: errorLogs.length,
        latency: await this.getServiceLatency(service),
        instances: await this.getServiceInstances(service)
      };
    }

    return health;
  }

  calculateSLA(metrics) {
    const totalRequests = metrics.requestRate.value * 300; // 5분간 요청 수
    const errorRequests = metrics.errorRate.value * 300;
    const successRate = (1 - (errorRequests / totalRequests)) * 100;
    
    return {
      current: successRate.toFixed(3),
      target: 99.99,
      status: successRate >= 99.99 ? 'meeting' : 'below'
    };
  }
}

// Grafana 대시보드 설정
{
  "dashboard": {
    "title": "IoT Platform V3 - Enterprise Dashboard",
    "panels": [
      {
        "title": "Global Request Rate",
        "targets": [{
          "expr": "sum(rate(http_requests_total[5m])) by (region)"
        }],
        "type": "graph"
      },
      {
        "title": "Tenant Distribution",
        "targets": [{
          "expr": "count by (plan) (tenant_info)"
        }],
        "type": "piechart"
      },
      {
        "title": "Device Connectivity",
        "targets": [{
          "expr": "sum(device_online_total) by (tenant_id)"
        }],
        "type": "stat"
      },
      {
        "title": "API Latency by Endpoint",
        "targets": [{
          "expr": "histogram_quantile(0.95, http_request_duration_seconds_bucket) by (endpoint)"
        }],
        "type": "heatmap"
      },
      {
        "title": "Business Metrics",
        "targets": [
          {
            "expr": "sum(api_calls_total) by (tenant_id)",
            "legendFormat": "API Calls"
          },
          {
            "expr": "sum(automation_executions_total) by (tenant_id)",
            "legendFormat": "Automations"
          },
          {
            "expr": "sum(voice_commands_total) by (tenant_id)",
            "legendFormat": "Voice Commands"
          }
        ],
        "type": "table"
      }
    ]
  }
}
```

## 7. V3 완료 체크리스트

### 기술적 목표 달성
- [ ] 20+ 마이크로서비스 분리 완료
- [ ] 멀티테넌시 완벽 구현
- [ ] 4개 지역 글로벌 배포
- [ ] 99.99% SLA 달성
- [ ] 1M req/sec 처리 가능
- [ ] 10M+ 디바이스 연결 지원

### 비즈니스 기능
- [ ] 화이트라벨 B2B 솔루션
- [ ] 엔터프라이즈 통합 (Salesforce, SAP 등)
- [ ] 고급 분석 대시보드
- [ ] API 마켓플레이스
- [ ] 사용량 기반 과금
- [ ] 6개 언어 지원

### 보안 및 규정 준수
- [ ] SOC2 Type II 인증
- [ ] ISO 27001 인증
- [ ] GDPR 준수
- [ ] 엔드투엔드 암호화
- [ ] 감사 로그 완비
- [ ] 재해 복구 계획

이제 V3 엔터프라이즈 플랫폼이 완성되었습니다! 

## 다음 단계

V4에서는 다음과 같은 혁신적인 기능들을 추가할 수 있습니다:
- **디지털 트윈**: 물리적 공간의 가상 복제
- **블록체인 기반 디바이스 신뢰 네트워크**
- **양자 내성 암호화**
- **AR/VR 인터페이스**
- **자율 운영 AI 시스템**

V4로 계속 진행하시겠습니까?