```
# ========== RASPBERRY PI CLIENT ==========

# === Main Application ===
# main.py
import asyncio
import logging
import signal
import sys
from pathlib import Path
import yaml

from audio.microphone import Microphone
from audio.speaker import Speaker
from audio.wake_word import WakeWordDetector
from sensors.motion_sensor import MotionSensor
from sensors.environment_sensor import EnvironmentSensor
from communication.mqtt_client import MqttClient
from communication.websocket_client import WebSocketClient
from core.device_manager import DeviceManager
from core.event_handler import EventHandler

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class AiSpeaker:
    def __init__(self, config_path='config.yaml'):
        """AI 스피커 초기화"""
        self.config = self._load_config(config_path)
        self.running = False
        
        # 컴포넌트 초기화
        self.microphone = Microphone(self.config['audio'])
        self.speaker = Speaker(self.config['audio'])
        self.wake_word_detector = WakeWordDetector(self.config['wake_word'])
        
        # 센서 초기화
        self.motion_sensor = MotionSensor(self.config['sensors']['motion'])
        self.environment_sensor = EnvironmentSensor(self.config['sensors']['environment'])
        
        # 통신 클라이언트
        self.mqtt_client = MqttClient(self.config['mqtt'])
        self.ws_client = WebSocketClient(self.config['websocket'])
        
        # 매니저
        self.device_manager = DeviceManager(self.config['device'])
        self.event_handler = EventHandler(self)
        
    def _load_config(self, config_path):
        """설정 파일 로드"""
        with open(config_path, 'r') as f:
            return yaml.safe_load(f)
    
    async def start(self):
        """AI 스피커 시작"""
        logger.info("Starting AI Speaker...")
        self.running = True
        
        # MQTT 연결
        await self.mqtt_client.connect()
        
        # WebSocket 연결 (옵션)
        if self.config.get('websocket', {}).get('enabled', False):
            await self.ws_client.connect()
        
        # 디바이스 등록
        await self._register_device()
        
        # 비동기 태스크 시작
        tasks = [
            asyncio.create_task(self._wake_word_loop()),
            asyncio.create_task(self._sensor_monitoring_loop()),
            asyncio.create_task(self._heartbeat_loop()),
        ]
        
        # 모든 태스크 실행
        await asyncio.gather(*tasks)
    
    async def stop(self):
        """AI 스피커 정지"""
        logger.info("Stopping AI Speaker...")
        self.running = False
        
        # 연결 종료
        await self.mqtt_client.disconnect()
        if self.ws_client.is_connected():
            await self.ws_client.disconnect()
        
        # 리소스 정리
        self.microphone.close()
        self.speaker.close()
        self.wake_word_detector.close()
    
    async def _wake_word_loop(self):
        """Wake word 감지 루프"""
        logger.info("Starting wake word detection...")
        
        while self.running:
            try:
                # 오디오 프레임 읽기
                audio_frame = self.microphone.read_frame()
                
                # Wake word 감지
                wake_word_index = self.wake_word_detector.process(audio_frame)
                
                if wake_word_index >= 0:
                    logger.info("Wake word detected!")
                    await self._handle_voice_interaction()
                    
            except Exception as e:
                logger.error(f"Error in wake word loop: {e}")
                await asyncio.sleep(0.1)
    
    async def _handle_voice_interaction(self):
        """음성 상호작용 처리"""
        try:
            # 리스닝 시작 알림
            self.speaker.play_sound('listening_start.wav')
            
            # 음성 녹음 (최대 5초)
            logger.info("Recording audio...")
            audio_data = self.microphone.record(duration=5.0)
            
            # 리스닝 종료 알림
            self.speaker.play_sound('listening_end.wav')
            
            # 서버로 전송
            response = await self._send_audio_to_server(audio_data)
            
            if response and 'speech' in response:
                # TTS 응답 재생
                logger.info(f"Playing response: {response['speech']}")
                await self.speaker.speak_async(response['speech'])
                
                # 액션 처리
                if 'actions' in response:
                    await self.event_handler.handle_actions(response['actions'])
                    
        except Exception as e:
            logger.error(f"Error in voice interaction: {e}")
            self.speaker.play_sound('error.wav')
    
    async def _send_audio_to_server(self, audio_data):
        """오디오 데이터를 서버로 전송"""
        import base64
        
        # 오디오 데이터를 base64로 인코딩
        audio_base64 = base64.b64encode(audio_data.tobytes()).decode('utf-8')
        
        # MQTT로 전송
        request_id = self.device_manager.generate_request_id()
        
        await self.mqtt_client.publish(
            f'device/{self.device_manager.device_id}/audio',
            {
                'requestId': request_id,
                'userId': self.device_manager.user_id,
                'sessionId': self.device_manager.session_id,
                'audio': audio_base64,
                'format': {
                    'encoding': 'LINEAR16',
                    'sampleRate': 16000,
                    'channels': 1
                }
            }
        )
        
        # 응답 대기
        response = await self.mqtt_client.wait_for_response(
            f'device/{self.device_manager.device_id}/response',
            request_id,
            timeout=10.0
        )
        
        return response
    
    async def _sensor_monitoring_loop(self):
        """센서 모니터링 루프"""
        logger.info("Starting sensor monitoring...")
        
        while self.running:
            try:
                # 모션 감지
                if self.motion_sensor.is_motion_detected():
                    await self.event_handler.handle_motion_event()
                
                # 환경 데이터 수집 (1분마다)
                if asyncio.get_event_loop().time() % 60 < 1:
                    env_data = self.environment_sensor.read_all()
                    await self.event_handler.handle_environment_data(env_data)
                
                await asyncio.sleep(0.5)
                
            except Exception as e:
                logger.error(f"Error in sensor monitoring: {e}")
                await asyncio.sleep(1.0)
    
    async def _heartbeat_loop(self):
        """하트비트 전송 루프"""
        while self.running:
            try:
                await self.mqtt_client.publish(
                    f'device/{self.device_manager.device_id}/heartbeat',
                    {
                        'timestamp': int(time.time()),
                        'status': 'online',
                        'version': self.config['device']['version']
                    }
                )
                await asyncio.sleep(30)  # 30초마다
                
            except Exception as e:
                logger.error(f"Error sending heartbeat: {e}")
                await asyncio.sleep(30)
    
    async def _register_device(self):
        """디바이스 등록"""
        await self.mqtt_client.publish(
            'device/register',
            {
                'deviceId': self.device_manager.device_id,
                'deviceType': 'ai-speaker',
                'version': self.config['device']['version'],
                'capabilities': [
                    'audio-input',
                    'audio-output',
                    'motion-detection',
                    'environment-sensing'
                ]
            }
        )

# === Audio Module ===
# audio/__init__.py
from .microphone import Microphone
from .speaker import Speaker
from .wake_word import WakeWordDetector

# audio/microphone.py
import pyaudio
import numpy as np
import threading
import queue
import logging

logger = logging.getLogger(__name__)

class Microphone:
    def __init__(self, config):
        self.sample_rate = config.get('sample_rate', 16000)
        self.channels = config.get('channels', 1)
        self.chunk_size = config.get('chunk_size', 512)
        self.format = pyaudio.paInt16
        
        self.audio = pyaudio.PyAudio()
        self.stream = None
        self.recording = False
        self.audio_queue = queue.Queue()
        
    def open(self):
        """마이크 스트림 열기"""
        if self.stream is None:
            self.stream = self.audio.open(
                format=self.format,
                channels=self.channels,
                rate=self.sample_rate,
                input=True,
                frames_per_buffer=self.chunk_size,
                stream_callback=self._audio_callback
            )
            self.stream.start_stream()
            logger.info("Microphone stream opened")
    
    def close(self):
        """마이크 스트림 닫기"""
        if self.stream:
            self.stream.stop_stream()
            self.stream.close()
            self.stream = None
        self.audio.terminate()
        logger.info("Microphone stream closed")
    
    def read_frame(self):
        """단일 오디오 프레임 읽기"""
        if self.stream is None:
            self.open()
        
        data = self.stream.read(self.chunk_size, exception_on_overflow=False)
        return np.frombuffer(data, dtype=np.int16)
    
    def record(self, duration):
        """지정된 시간 동안 녹음"""
        if self.stream is None:
            self.open()
        
        frames = []
        chunks_to_record = int(self.sample_rate * duration / self.chunk_size)
        
        logger.info(f"Recording {duration} seconds...")
        
        for _ in range(chunks_to_record):
            data = self.stream.read(self.chunk_size)
            frames.append(data)
        
        # numpy 배열로 변환
        audio_data = np.frombuffer(b''.join(frames), dtype=np.int16)
        
        return audio_data
    
    def _audio_callback(self, in_data, frame_count, time_info, status):
        """오디오 스트림 콜백"""
        if self.recording:
            self.audio_queue.put(in_data)
        return (in_data, pyaudio.paContinue)

# audio/speaker.py
import pyaudio
import numpy as np
import logging
import asyncio
from pathlib import Path
import wave
import aiohttp

logger = logging.getLogger(__name__)

class Speaker:
    def __init__(self, config):
        self.sample_rate = config.get('sample_rate', 16000)
        self.channels = config.get('channels', 1)
        self.chunk_size = config.get('chunk_size', 1024)
        self.format = pyaudio.paInt16
        
        self.audio = pyaudio.PyAudio()
        self.stream = None
        self.tts_url = config.get('tts_url')
        self.sound_dir = Path(config.get('sound_dir', 'sounds'))
        
    def open(self):
        """스피커 스트림 열기"""
        if self.stream is None:
            self.stream = self.audio.open(
                format=self.format,
                channels=self.channels,
                rate=self.sample_rate,
                output=True,
                frames_per_buffer=self.chunk_size
            )
            logger.info("Speaker stream opened")
    
    def close(self):
        """스피커 스트림 닫기"""
        if self.stream:
            self.stream.stop_stream()
            self.stream.close()
            self.stream = None
        self.audio.terminate()
        logger.info("Speaker stream closed")
    
    def play_audio(self, audio_data):
        """오디오 데이터 재생"""
        if self.stream is None:
            self.open()
        
        # int16으로 변환
        if audio_data.dtype != np.int16:
            audio_data = (audio_data * 32767).astype(np.int16)
        
        self.stream.write(audio_data.tobytes())
    
    def play_sound(self, filename):
        """사운드 파일 재생"""
        sound_path = self.sound_dir / filename
        
        if not sound_path.exists():
            logger.warning(f"Sound file not found: {sound_path}")
            return
        
        with wave.open(str(sound_path), 'rb') as wf:
            data = wf.readframes(wf.getnframes())
            self.play_audio(np.frombuffer(data, dtype=np.int16))
    
    async def speak_async(self, text):
        """텍스트를 음성으로 변환하여 재생 (비동기)"""
        try:
            # TTS API 호출
            audio_data = await self._get_tts_audio(text)
            
            if audio_data:
                # 별도 스레드에서 재생
                await asyncio.get_event_loop().run_in_executor(
                    None, self.play_audio, audio_data
                )
            else:
                logger.error("Failed to get TTS audio")
                
        except Exception as e:
            logger.error(f"Error in speak_async: {e}")
    
    async def _get_tts_audio(self, text):
        """TTS API를 통해 오디오 데이터 획득"""
        if not self.tts_url:
            logger.warning("TTS URL not configured")
            return None
        
        async with aiohttp.ClientSession() as session:
            try:
                async with session.post(
                    self.tts_url,
                    json={'text': text, 'language': 'ko-KR'},
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status == 200:
                        audio_bytes = await response.read()
                        return np.frombuffer(audio_bytes, dtype=np.int16)
                    else:
                        logger.error(f"TTS API error: {response.status}")
                        return None
                        
            except Exception as e:
                logger.error(f"TTS API request failed: {e}")
                return None

# audio/wake_word.py
import pvporcupine
import numpy as np
import logging
import struct

logger = logging.getLogger(__name__)

class WakeWordDetector:
    def __init__(self, config):
        self.access_key = config['access_key']
        self.keyword_paths = config.get('keyword_paths', [])
        self.keywords = config.get('keywords', ['porcupine'])
        self.sensitivities = config.get('sensitivities', [0.5])
        
        self.porcupine = None
        self._initialize()
    
    def _initialize(self):
        """Porcupine 초기화"""
        try:
            if self.keyword_paths:
                # 커스텀 키워드 사용
                self.porcupine = pvporcupine.create(
                    access_key=self.access_key,
                    keyword_paths=self.keyword_paths,
                    sensitivities=self.sensitivities
                )
            else:
                # 빌트인 키워드 사용
                self.porcupine = pvporcupine.create(
                    access_key=self.access_key,
                    keywords=self.keywords,
                    sensitivities=self.sensitivities
                )
            
            logger.info(f"Wake word detector initialized with keywords: {self.keywords}")
            
        except Exception as e:
            logger.error(f"Failed to initialize Porcupine: {e}")
            raise
    
    def process(self, audio_frame):
        """오디오 프레임에서 wake word 감지"""
        if self.porcupine is None:
            return -1
        
        # Porcupine은 512 샘플 프레임 필요
        if len(audio_frame) != self.porcupine.frame_length:
            logger.warning(f"Invalid frame length: {len(audio_frame)}")
            return -1
        
        # int16을 Porcupine 형식으로 변환
        pcm = struct.unpack_from("h" * self.porcupine.frame_length, audio_frame)
        
        # Wake word 감지
        keyword_index = self.porcupine.process(pcm)
        
        return keyword_index
    
    def close(self):
        """리소스 정리"""
        if self.porcupine:
            self.porcupine.delete()
            self.porcupine = None
            logger.info("Wake word detector closed")

# === Sensors Module ===
# sensors/__init__.py
from .motion_sensor import MotionSensor
from .environment_sensor import EnvironmentSensor

# sensors/motion_sensor.py
import RPi.GPIO as GPIO
import time
import logging
import threading

logger = logging.getLogger(__name__)

class MotionSensor:
    def __init__(self, config):
        self.pin = config['pin']
        self.detection_interval = config.get('detection_interval', 0.5)
        self.cooldown_time = config.get('cooldown_time', 5.0)
        
        self.last_motion_time = 0
        self.motion_detected = False
        self.callbacks = []
        
        self._setup_gpio()
        self._start_monitoring()
    
    def _setup_gpio(self):
        """GPIO 설정"""
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.pin, GPIO.IN)
        GPIO.add_event_detect(
            self.pin, 
            GPIO.RISING, 
            callback=self._motion_callback,
            bouncetime=300
        )
        logger.info(f"Motion sensor initialized on pin {self.pin}")
    
    def _motion_callback(self, channel):
        """모션 감지 콜백"""
        current_time = time.time()
        
        # 쿨다운 시간 체크
        if current_time - self.last_motion_time < self.cooldown_time:
            return
        
        self.motion_detected = True
        self.last_motion_time = current_time
        
        logger.info("Motion detected!")
        
        # 등록된 콜백 실행
        for callback in self.callbacks:
            try:
                callback()
            except Exception as e:
                logger.error(f"Error in motion callback: {e}")
    
    def _start_monitoring(self):
        """모니터링 스레드 시작"""
        def monitor():
            while True:
                if self.motion_detected:
                    # 일정 시간 후 플래그 리셋
                    time.sleep(self.detection_interval)
                    self.motion_detected = False
                time.sleep(0.1)
        
        thread = threading.Thread(target=monitor, daemon=True)
        thread.start()
    
    def is_motion_detected(self):
        """현재 모션 감지 상태 반환"""
        return self.motion_detected
    
    def add_callback(self, callback):
        """모션 감지 콜백 추가"""
        self.callbacks.append(callback)
    
    def cleanup(self):
        """GPIO 정리"""
        GPIO.cleanup(self.pin)
        logger.info("Motion sensor cleaned up")

# sensors/environment_sensor.py
import logging
import time
try:
    import adafruit_dht
    import board
except ImportError:
    logger.warning("DHT sensor libraries not available")
    adafruit_dht = None

logger = logging.getLogger(__name__)

class EnvironmentSensor:
    def __init__(self, config):
        self.sensor_type = config.get('type', 'DHT22')
        self.pin = config.get('pin', 'D4')
        self.read_interval = config.get('read_interval', 2.0)
        
        self.sensor = None
        self.last_read_time = 0
        self.last_data = {'temperature': None, 'humidity': None}
        
        self._initialize_sensor()
    
    def _initialize_sensor(self):
        """센서 초기화"""
        if adafruit_dht is None:
            logger.warning("DHT sensor not available - using mock data")
            return
        
        try:
            # 핀 매핑
            pin = getattr(board, self.pin)
            
            # 센서 타입에 따라 초기화
            if self.sensor_type == 'DHT22':
                self.sensor = adafruit_dht.DHT22(pin)
            elif self.sensor_type == 'DHT11':
                self.sensor = adafruit_dht.DHT11(pin)
            else:
                raise ValueError(f"Unsupported sensor type: {self.sensor_type}")
            
            logger.info(f"Environment sensor {self.sensor_type} initialized on pin {self.pin}")
            
        except Exception as e:
            logger.error(f"Failed to initialize environment sensor: {e}")
            self.sensor = None
    
    def read_temperature(self):
        """온도 읽기"""
        data = self._read_sensor()
        return data['temperature']
    
    def read_humidity(self):
        """습도 읽기"""
        data = self._read_sensor()
        return data['humidity']
    
    def read_all(self):
        """온도와 습도 모두 읽기"""
        return self._read_sensor()
    
    def _read_sensor(self):
        """센서 데이터 읽기"""
        current_time = time.time()
        
        # 읽기 간격 체크
        if current_time - self.last_read_time < self.read_interval:
            return self.last_data
        
        if self.sensor is None:
            # 모의 데이터 반환
            self.last_data = {
                'temperature': 22.5,
                'humidity': 45.0,
                'timestamp': current_time
            }
        else:
            try:
                # 실제 센서에서 읽기
                temperature = self.sensor.temperature
                humidity = self.sensor.humidity
                
                if temperature is not None and humidity is not None:
                    self.last_data = {
                        'temperature': temperature,
                        'humidity': humidity,
                        'timestamp': current_time
                    }
                    logger.debug(f"Environment: {temperature}°C, {humidity}%")
                    
            except Exception as e:
                logger.error(f"Error reading sensor: {e}")
        
        self.last_read_time = current_time
        return self.last_data
    
    def cleanup(self):
        """센서 정리"""
        if self.sensor:
            self.sensor.exit()
            logger.info("Environment sensor cleaned up")

# === Communication Module ===
# communication/__init__.py
from .mqtt_client import MqttClient
from .websocket_client import WebSocketClient

# communication/mqtt_client.py
import asyncio
import json
import logging
import time
import uuid
from typing import Dict, Any, Optional
import paho.mqtt.client as mqtt

logger = logging.getLogger(__name__)

class MqttClient:
    def __init__(self, config):
        self.broker_url = config['broker_url']
        self.port = config.get('port', 1883)
        self.client_id = config.get('client_id', f'ai-speaker-{uuid.uuid4().hex[:8]}')
        self.username = config.get('username')
        self.password = config.get('password')
        
        self.client = None
        self.connected = False
        self.subscriptions = {}
        self.response_futures = {}
        
        self._setup_client()
    
    def _setup_client(self):
        """MQTT 클라이언트 설정"""
        self.client = mqtt.Client(self.client_id)
        
        # 인증 설정
        if self.username and self.password:
            self.client.username_pw_set(self.username, self.password)
        
        # 콜백 설정
        self.client.on_connect = self._on_connect
        self.client.on_disconnect = self._on_disconnect
        self.client.on_message = self._on_message
        
        logger.info(f"MQTT client configured: {self.client_id}")
    
    async def connect(self):
        """MQTT 브로커에 연결"""
        try:
            self.client.connect_async(self.broker_url, self.port, 60)
            self.client.loop_start()
            
            # 연결 대기
            for _ in range(50):  # 5초 대기
                if self.connected:
                    logger.info(f"Connected to MQTT broker: {self.broker_url}")
                    return True
                await asyncio.sleep(0.1)
            
            raise TimeoutError("MQTT connection timeout")
            
        except Exception as e:
            logger.error(f"Failed to connect to MQTT broker: {e}")
            raise
    
    async def disconnect(self):
        """MQTT 연결 해제"""
        if self.client:
            self.client.loop_stop()
            self.client.disconnect()
            self.connected = False
            logger.info("Disconnected from MQTT broker")
    
    async def publish(self, topic: str, payload: Dict[str, Any], qos: int = 1):
        """메시지 발행"""
        if not self.connected:
            logger.error("Not connected to MQTT broker")
            return False
        
        try:
            message = json.dumps(payload)
            result = self.client.publish(topic, message, qos)
            
            if result.rc == mqtt.MQTT_ERR_SUCCESS:
                logger.debug(f"Published to {topic}: {message[:100]}...")
                return True
            else:
                logger.error(f"Failed to publish to {topic}: {result.rc}")
                return False
                
        except Exception as e:
            logger.error(f"Error publishing message: {e}")
            return False
    
    async def subscribe(self, topic: str, callback=None):
        """토픽 구독"""
        if not self.connected:
            logger.error("Not connected to MQTT broker")
            return False
        
        self.client.subscribe(topic)
        
        if callback:
            self.subscriptions[topic] = callback
        
        logger.info(f"Subscribed to topic: {topic}")
        return True
    
    async def wait_for_response(self, topic: str, request_id: str, timeout: float = 10.0):
        """응답 대기"""
        future = asyncio.Future()
        self.response_futures[request_id] = future
        
        # 응답 토픽 구독
        await self.subscribe(topic)
        
        try:
            # 타임아웃 설정하여 대기
            response = await asyncio.wait_for(future, timeout)
            return response
            
        except asyncio.TimeoutError:
            logger.warning(f"Response timeout for request {request_id}")
            return None
            
        finally:
            # 정리
            self.response_futures.pop(request_id, None)
    
    def _on_connect(self, client, userdata, flags, rc):
        """연결 콜백"""
        if rc == 0:
            self.connected = True
            logger.info("MQTT connected successfully")
            
            # 기본 구독 설정
            client.subscribe("device/+/command")
            
        else:
            logger.error(f"MQTT connection failed with code: {rc}")
    
    def _on_disconnect(self, client, userdata, rc):
        """연결 해제 콜백"""
        self.connected = False
        
        if rc != 0:
            logger.warning(f"Unexpected MQTT disconnection: {rc}")
        else:
            logger.info("MQTT disconnected")
    
    def _on_message(self, client, userdata, msg):
        """메시지 수신 콜백"""
        try:
            topic = msg.topic
            payload = json.loads(msg.payload.decode('utf-8'))
            
            logger.debug(f"Received message on {topic}: {payload}")
            
            # 응답 대기 중인 요청 확인
            request_id = payload.get('requestId')
            if request_id and request_id in self.response_futures:
                future = self.response_futures[request_id]
                if not future.done():
                    future.set_result(payload)
            
            # 구독 콜백 실행
            for pattern, callback in self.subscriptions.items():
                if self._topic_matches(pattern, topic):
                    asyncio.create_task(callback(topic, payload))
                    
        except Exception as e:
            logger.error(f"Error processing message: {e}")
    
    def _topic_matches(self, pattern: str, topic: str) -> bool:
        """토픽 패턴 매칭"""
        pattern_parts = pattern.split('/')
        topic_parts = topic.split('/')
        
        if len(pattern_parts) != len(topic_parts):
            return False
        
        for p, t in zip(pattern_parts, topic_parts):
            if p == '+':
                continue
            elif p == '#':
                return True
            elif p != t:
                return False
        
        return True

# communication/websocket_client.py
import asyncio
import json
import logging
import websockets
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

class WebSocketClient:
    def __init__(self, config):
        self.url = config.get('url', 'ws://localhost:8080/ws/audio')
        self.reconnect_interval = config.get('reconnect_interval', 5)
        self.ping_interval = config.get('ping_interval', 30)
        
        self.websocket = None
        self.connected = False
        self.running = False
        self.message_handlers = {}
    
    async def connect(self):
        """WebSocket 서버에 연결"""
        self.running = True
        asyncio.create_task(self._connection_loop())
    
    async def disconnect(self):
        """WebSocket 연결 해제"""
        self.running = False
        
        if self.websocket:
            await self.websocket.close()
            self.websocket = None
            self.connected = False
    
    async def send(self, message: Dict[str, Any]):
        """메시지 전송"""
        if not self.connected or not self.websocket:
            logger.error("WebSocket not connected")
            return False
        
        try:
            await self.websocket.send(json.dumps(message))
            return True
            
        except Exception as e:
            logger.error(f"Error sending WebSocket message: {e}")
            return False
    
    async def send_audio_stream(self, audio_generator):
        """오디오 스트림 전송"""
        if not self.connected:
            logger.error("WebSocket not connected")
            return
        
        try:
            async for audio_chunk in audio_generator:
                message = {
                    'type': 'audio_stream',
                    'data': audio_chunk.tobytes().hex()
                }
                await self.send(message)
                
        except Exception as e:
            logger.error(f"Error streaming audio: {e}")
    
    def add_handler(self, message_type: str, handler):
        """메시지 핸들러 추가"""
        self.message_handlers[message_type] = handler
    
    def is_connected(self) -> bool:
        """연결 상태 확인"""
        return self.connected
    
    async def _connection_loop(self):
        """연결 유지 루프"""
        while self.running:
            try:
                await self._connect_and_handle()
                
            except Exception as e:
                logger.error(f"WebSocket connection error: {e}")
                
            if self.running:
                logger.info(f"Reconnecting in {self.reconnect_interval} seconds...")
                await asyncio.sleep(self.reconnect_interval)
    
    async def _connect_and_handle(self):
        """연결 및 메시지 처리"""
        async with websockets.connect(self.url) as websocket:
            self.websocket = websocket
            self.connected = True
            logger.info(f"Connected to WebSocket: {self.url}")
            
            # 핑 태스크 시작
            ping_task = asyncio.create_task(self._ping_loop())
            
            try:
                # 메시지 수신 루프
                async for message in websocket:
                    await self._handle_message(message)
                    
            finally:
                ping_task.cancel()
                self.connected = False
                self.websocket = None
    
    async def _handle_message(self, message: str):
        """메시지 처리"""
        try:
            data = json.loads(message)
            message_type = data.get('type', 'unknown')
            
            logger.debug(f"Received WebSocket message: {message_type}")
            
            # 핸들러 실행
            handler = self.message_handlers.get(message_type)
            if handler:
                await handler(data)
            else:
                logger.warning(f"No handler for message type: {message_type}")
                
        except Exception as e:
            logger.error(f"Error handling WebSocket message: {e}")
    
    async def _ping_loop(self):
        """주기적 핑 전송"""
        while self.connected:
            try:
                await asyncio.sleep(self.ping_interval)
                
                if self.websocket:
                    await self.websocket.ping()
                    logger.debug("WebSocket ping sent")
                    
            except Exception as e:
                logger.error(f"Ping error: {e}")
                break

# === Core Module ===
# core/__init__.py
from .device_manager import DeviceManager
from .event_handler import EventHandler

# core/device_manager.py
import uuid
import json
import logging
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)

class DeviceManager:
    def __init__(self, config):
        self.config = config
        self.device_id = self._get_or_create_device_id()
        self.user_id = config.get('user_id', 'default_user')
        self.session_id = str(uuid.uuid4())
        
        logger.info(f"Device initialized: {self.device_id}")
    
    def _get_or_create_device_id(self) -> str:
        """디바이스 ID 가져오기 또는 생성"""
        device_file = Path.home() / '.ai_speaker' / 'device_id'
        
        if device_file.exists():
            with open(device_file, 'r') as f:
                device_id = f.read().strip()
                logger.info(f"Loaded existing device ID: {device_id}")
                return device_id
        else:
            # 새 디바이스 ID 생성
            device_id = f"speaker-{uuid.uuid4().hex[:12]}"
            
            # 디렉토리 생성
            device_file.parent.mkdir(parents=True, exist_ok=True)
            
            # ID 저장
            with open(device_file, 'w') as f:
                f.write(device_id)
            
            logger.info(f"Created new device ID: {device_id}")
            return device_id
    
    def generate_request_id(self) -> str:
        """요청 ID 생성"""
        return f"{self.device_id}-{uuid.uuid4().hex[:8]}"
    
    def new_session(self) -> str:
        """새 세션 ID 생성"""
        self.session_id = str(uuid.uuid4())
        logger.info(f"New session created: {self.session_id}")
        return self.session_id
    
    def get_device_info(self) -> dict:
        """디바이스 정보 반환"""
        return {
            'deviceId': self.device_id,
            'userId': self.user_id,
            'sessionId': self.session_id,
            'version': self.config.get('version', '1.0.0'),
            'capabilities': self.config.get('capabilities', [])
        }

# core/event_handler.py
import asyncio
import logging
from datetime import datetime
from typing import Dict, Any, List

logger = logging.getLogger(__name__)

class EventHandler:
    def __init__(self, speaker):
        self.speaker = speaker
        self.last_motion_time = None
        self.daily_greeted = False
        self.event_history = []
    
    async def handle_motion_event(self):
        """모션 이벤트 처리"""
        current_time = datetime.now()
        
        # 이벤트 기록
        self._record_event('motion', {'time': current_time})
        
        # MQTT로 이벤트 전송
        await self.speaker.mqtt_client.publish(
            f'device/{self.speaker.device_manager.device_id}/event',
            {
                'type': 'motion',
                'timestamp': int(current_time.timestamp()),
                'data': {
                    'location': 'living_room'
                }
            }
        )
        
        # 아침 인사 체크
        if not self.daily_greeted and 6 <= current_time.hour < 10:
            if self._should_greet_morning():
                self.daily_greeted = True
                # 서버에 프로액티브 대화 요청
                await self._request_proactive_dialog('morning_greeting')
        
        self.last_motion_time = current_time
    
    async def handle_environment_data(self, data: Dict[str, Any]):
        """환경 데이터 처리"""
        # 이벤트 기록
        self._record_event('environment', data)
        
        # MQTT로 전송
        await self.speaker.mqtt_client.publish(
            f'device/{self.speaker.device_manager.device_id}/telemetry',
            {
                'type': 'environment',
                'timestamp': int(datetime.now().timestamp()),
                'data': data
            }
        )
        
        # 이상 상태 감지
        if self._detect_anomaly(data):
            await self._request_proactive_dialog('environment_alert', data)
    
    async def handle_actions(self, actions: List[Dict[str, Any]]):
        """서버로부터 받은 액션 처리"""
        for action in actions:
            action_type = action.get('type')
            
            logger.info(f"Processing action: {action_type}")
            
            if action_type == 'play_sound':
                sound_file = action.get('sound')
                self.speaker.speaker.play_sound(sound_file)
                
            elif action_type == 'control_device':
                # IoT 디바이스 제어
                await self._control_iot_device(action)
                
            elif action_type == 'set_reminder':
                # 리마인더 설정
                await self._set_reminder(action)
                
            else:
                logger.warning(f"Unknown action type: {action_type}")
    
    def _record_event(self, event_type: str, data: Any):
        """이벤트 기록"""
        event = {
            'type': event_type,
            'timestamp': datetime.now(),
            'data': data
        }
        
        self.event_history.append(event)
        
        # 최대 1000개 유지
        if len(self.event_history) > 1000:
            self.event_history = self.event_history[-1000:]
    
    def _should_greet_morning(self) -> bool:
        """아침 인사 여부 결정"""
        if not self.last_motion_time:
            return True
        
        # 마지막 모션이 1시간 이상 전이면 인사
        time_diff = datetime.now() - self.last_motion_time
        return time_diff.total_seconds() > 3600
    
    def _detect_anomaly(self, env_data: Dict[str, Any]) -> bool:
        """환경 이상 감지"""
        temp = env_data.get('temperature', 20)
        humidity = env_data.get('humidity', 50)
        
        # 온도 이상
        if temp < 10 or temp > 35:
            return True
        
        # 습도 이상
        if humidity < 20 or humidity > 80:
            return True
        
        return False
    
    async def _request_proactive_dialog(self, rule_name: str, context: Dict = None):
        """프로액티브 대화 요청"""
        await self.speaker.mqtt_client.publish(
            f'device/{self.speaker.device_manager.device_id}/proactive',
            {
                'rule': rule_name,
                'context': context or {},
                'timestamp': int(datetime.now().timestamp())
            }
        )
    
    async def _control_iot_device(self, action: Dict[str, Any]):
        """IoT 디바이스 제어"""
        device_id = action.get('deviceId')
        command = action.get('command')
        
        logger.info(f"Controlling device {device_id}: {command}")
        
        # 실제 IoT 제어 로직 구현
        # ...
    
    async def _set_reminder(self, action: Dict[str, Any]):
        """리마인더 설정"""
        reminder_time = action.get('time')
        message = action.get('message')
        
        logger.info(f"Setting reminder at {reminder_time}: {message}")
        
        # 리마인더 로직 구현
        # ...
    
    def reset_daily_state(self):
        """일일 상태 리셋 (자정에 호출)"""
        self.daily_greeted = False
        logger.info("Daily state reset")

# === Configuration File ===
# config.yaml
device:
  version: "1.0.0"
  user_id: "default_user"
  capabilities:
    - "audio-input"
    - "audio-output"
    - "motion-detection"
    - "environment-sensing"
    - "wake-word"

audio:
  sample_rate: 16000
  channels: 1
  chunk_size: 512
  sound_dir: "sounds"
  tts_url: "http://localhost:8080/api/tts"

wake_word:
  access_key: "YOUR_PORCUPINE_ACCESS_KEY"
  keywords: ["hey speaker"]
  sensitivities: [0.5]

sensors:
  motion:
    pin: 17
    detection_interval: 0.5
    cooldown_time: 5.0
  environment:
    type: "DHT22"
    pin: "D4"
    read_interval: 2.0

mqtt:
  broker_url: "localhost"
  port: 1883
  username: ""
  password: ""

websocket:
  enabled: false
  url: "ws://localhost:8080/ws/audio"
  reconnect_interval: 5
  ping_interval: 30

# === Entry Point ===
# run.py
#!/usr/bin/env python3
import asyncio
import signal
import sys
import logging
from main import AiSpeaker

logger = logging.getLogger(__name__)

async def main():
    """메인 실행 함수"""
    speaker = AiSpeaker()
    
    # 종료 시그널 처리
    def signal_handler(sig, frame):
        logger.info("Shutting down...")
        asyncio.create_task(speaker.stop())
        sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    try:
        # AI 스피커 시작
        await speaker.start()
        
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        await speaker.stop()
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())

# === Setup Script ===
# setup.sh
#!/bin/bash
echo "Setting up AI Speaker on Raspberry Pi..."

# Update system
sudo apt-get update
sudo apt-get upgrade -y

# Install system dependencies
sudo apt-get install -y \
    python3-pip \
    python3-venv \
    portaudio19-dev \
    python3-pyaudio \
    libatlas-base-dev \
    libgfortran5

# Create virtual environment
python3 -m venv venv
source venv/bin/activate

# Install Python dependencies
pip install --upgrade pip
pip install -r requirements.txt

# Create directories
mkdir -p sounds
mkdir -p logs
mkdir -p ~/.ai_speaker

# Download sample sounds
echo "Downloading sample sounds..."
# wget sample sounds...

echo "Setup complete! Run 'python run.py' to start the AI Speaker."
```